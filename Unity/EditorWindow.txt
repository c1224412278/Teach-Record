
 !!! ( 實用 繪製GUI 平台教學 )
https://play2gethergamenote.blogspot.com/2016/10/unity-custom-inspector_23.html

* OnPosrRender (可在Game視窗，執行等同於 OnSceneGUI 功能)

using UnityEditorInternal;	//自訂排序工具
( https://play2gethergamenote.blogspot.com/2016/10/unity-custom-inspector_25.html )


------------	serializedObject	---------------------------

serializedObject.Update () 可以重新進行資料更新。
serializedObject.ApplyModifiedProperties () 可以對資料更動進行寫入。


------------	EditorWindow	------------------------------------

using UnityEditor;
public class AlphaMaskWindow : EditorWindow  <----   這樣才能使用

[MenuItem("Tools/Alpha Mask Maker")]  
	private static void OpenWindow()  
	{  
		EditorWindow.GetWindow<AlphaMaskWindow> ().Show ();  
	} 


----------------------------------------------------------------------

* DrawDefaultInspector(); 	// 會將原本的資料畫出來 (超重要)
* EditorApplication.Beep();	//系統會發出聲音 (提醒)
* EditorUtility.SetDirty(;	//儲存資料
* EditorUtility.DisplayDialog	//出現 ( 確定要執行 *是 *否 ) 視窗

* HandleUtility (用途 : 3D 場景與 2D - GUI 之間的轉換過程。)

	獲取滑鼠位置 : Event guiEvent = Event.current;
	獲取滑鼠射線世界座標 : HandleUtility.GUIPointToWorldRay (guiEvent.mousePosition);

	if(guiEvent.type == EventType.layout)
	{
		HandleUtility.AddDefaultControl (GUIUtility.GetControlID(FocusType.Passive));	
	}

* 判斷需按下哪個鍵盤按鍵進行動作 : guiEvent.modifiers == 


Event guiEvent = Event.current;			//當前事件
Rect.Contains(guiEvent.mousePosition)		//可判斷 鼠標 是否在目標身上

------------	EditorGUI	--------------------------------------

繪製欄位	EditorGUI.PropertyField

** EditorGUILayout 與 GUILayout 的差距

	EditorGUILayout.Toggle ("EditorGUILayout.Toggle" , false); 
	GUILayout.Toggle (false , "EditorGUILayout.Toggle");   作範例 ------------------

	* GUILayout 只可繪製 TextField 欄位 (其他欄位不支援 V3 V4 Color .... )
	
	
* 新增區域 	GUILayout.BeginArea (Rect);
		GUILayout.EndArea ();


* 設為一個群組

	* GUILayout.BeginHorizontal();
	{

	}
	GUILayout.EndHorizontal();

* 判斷之間的數值是否有變動 

	@ 判斷 BeginChangeCheck ~ EndChangeCheck 之間，是否有變數的變動

	EditorGUI.BeginChangeCheck();
        Color newColor = EditorGUILayout.ColorField(gradient.GetKey(selectedKeyIndex).Colour);

        if (EditorGUI.EndChangeCheck())
        {
            
        }

EditorGUI.MultiFloatField (
	new Rect(30 , 100 , 200 , EditorGUIUtility.singleLineHeight) , new GUIContent("Label") , contexts , numbers);
	//宣告Vector3欄位   X[] , Y[] , Z[]



* 子物件 繪製
	EditorGUILayout.LabelField ("Parent");
	EditorGUI.indentLevel++;
	EditorGUILayout.LabelField ("Child");
	EditorGUI.indentLevel--;
	EditorGUILayout.LabelField ("Parent");

------------	EditorGUILayout		--------------------------------------

			     (物件)     (型態)		//(假如宣告為Object，跑出存放Object的UI欄位)
EditorGUILayout.ObjectField (null , typeof(Object) , false);		

GUILayoutOption[] options = new []{GUILayout.Width(128) , GUILayout.Height(128)};	//改變欄位寬、高


EditorGUILayout.BeginToggleGroup	Toggle群組
EditorGUILayout.EndToggleGroup();


EditorStyles.miniButtonLef	欄位靠左補正空隙
EditorStyles.miniButtonMid	欄位靠中補正空隙
EditorStyles.miniButtonRight	欄位靠右補正空隙


SerializedProperty ser = serializedObject.FindProperty("抓取的變數名稱");
SerializedProperty nameID = npc.FindPropertyRelative("放下一層變數名稱");




------------	簡易 PropertyDrawer 用法	--------------------------------------

* 因為 EditorGUI 需要指定 Rect，所以大部分會和 PropertyDrawer 一起實作


	** https://blog.csdn.net/qq_33337811/article/details/66475651

	public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    	{
        	Range2Attribute range2 = (Range2Attribute)attribute;

        	if (property.propertyType == SerializedPropertyType.Integer)		//當變數為 int 時候
        	{
	    		EditorGUI.IntSlider(position , property , range2.min , range2.max , label);		// 繪製滾輪
        	}
        	else
        	{
            		EditorGUI.PropertyField(position , property , label);		//繪製普通欄位
        	}
    	}


	public override float GetPropertyHeight(SerializedProperty property, GUIContent label)		//設定 UI高度

	
	CustomGradient gradient = (CustomGradient)fieldInfo.GetValue(property.serializedObject.targetObject);	//獲取對象腳本
	GUI.skin.label.CalcSize(label).x		//單字寬度




