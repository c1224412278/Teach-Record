https://blog.csdn.net/zhenghongzhi6/article/details/79229585		//UniRx 解析
https://www.jianshu.com/p/94b857be40ec		//實戰筆記


* 重點 : Subscribe() 輸出後，並不會停止訂閱。
	var disposable = new CompositeDisposable();	
	disposable.Disposable = Observable.EveryUpdate()
    		.Subscribe(_ =>
    		{
        		if ()
        		{
           			 disposable.Dispose();		**** 此行可以停止繼續訂閱
        		}
    		});


When 等待完成  
WhenAll 等待所有完成，將資料結合
	Ex : 	var heavyMethod = Observable.Start(() => { return 10; });
    		var heavyMethod2 = Observable.Start(() => { return 20; });
    		Observable.WhenAll(heavyMethod, heavyMethod2)
        		.Subscribe(xs =>
        		{
            			Debug.Log(xs[0] + ":" + xs[1]);
        		});

yield return Observable.Range(0, 10).StartAsCoroutine()		回傳完成後的最後一個數值
	*  類似 for 迴圈的概念

Observable.Start	申明此函式只會執行一次
Observable.EveryUpdate() 做Update執行

Sample		延遲時間
Buffer(int)		緩衝。輸入int當數量達到一定數值，才一次性輸出
Buffer(int , int)	(不一定要寫) 緩衝。第二個 int 表示要輸出的數量

Observable.Defer	延遲評估
	* Ex : Return 數值會固定，與 Create不同。此時可以使用 Defer 延遲，讓數值不固定
		Observable.Defer(() => Observable.Return(random.Next()))
Return		返回數據
	Ex : Observable.Return(new Vector2(0, 1.5f)).Subscribe(v => gameObject.transform.position = v);

	Ex : var value = Observable.Return<string>("value");
        		value.Subscribe(x => Debug.Log(x));

Interval	將會使數值遞增
	Ex : Observable.Interval(TimeSpan.FromMilliseconds(1000))
        	.Subscribe(_ => { Debug.Log(_); });


Throttle	過一段時間，如果數據還沒放出時，等待幾秒暫停後才繼續執行
ThrottleFirst	先執行後，等待幾秒才能再次執行
	Ex :  	var clickStream = Observable.EveryUpdate()
        	.Where(_ => Input.GetMouseButtonDown(0));

    		clickStream.Buffer(clickStream.Throttle(TimeSpan.FromMilliseconds(250)))
        		.Where(xs => xs.Count >= 2)
        		.Subscribe(xs => Debug.Log("click count:" + xs.Count));


First		只發射第一個完成的數據
FirstOrDefault	( 協程使用 ) 直到完成第一件事情
	Ex : yield return this.OnCollisionEnterAsObservable()
        	.FirstOrDefault()
        	.Select(x => x.gameObject)
        	.Timeout(TimeSpan.FromSeconds(3))
        	.StartAsCoroutine(x => result = x, error => isTimeout = true);
	


Take(3)		只發射前面 N 項數據，完成之後返回，其餘省略
TakeUntil(this.UpdateAsObservable().Where(_ => Input.GetMouseButtonDown(0))	等待某個條件完成
TakeWhile(count => count < 2)		//可以決定等待秒數
		
		*(只能在 Take 尾部套用 ) Repeat()	當OnCompleted出現時，重新調用


Last		只發射最後一個數值
Distinct	過濾重複的選項
	Ex : var ss = new int[] { 1, 2, 5, 5, 6, 8, 9, 6 };
        	ss.ToObservable()
            	.Distinct()
            	.Subscribe(xx =>
            	{
            	    Debug.Log(xx);
            	});




